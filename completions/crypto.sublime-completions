{
    "scope": "source.js",
    "completions": [
        {
            "trigger": "new crypto.Certificate()\tcrypto",
            "contents": "new crypto.Certificate();$0"
        },
        {
            "trigger": "certificate.exportChallenge(spkac)\tcrypto",
            "contents": "certificate.exportChallenge(${1:spkac});$0"
        },
        {
            "trigger": "certificate.exportPublicKey(spkac)\tcrypto",
            "contents": "certificate.exportPublicKey(${1:spkac});$0"
        },
        {
            "trigger": "certificate.verifySpkac(spkac)\tcrypto",
            "contents": "certificate.verifySpkac(${1:spkac});$0"
        },
        {
            "trigger": "cipher.final([outputEncoding])\tcrypto",
            "contents": "cipher.final(${1:[, outputEncoding]});$0"
        },
        {
            "trigger": "cipher.setAAD(buffer)\tcrypto",
            "contents": "cipher.setAAD(${1:buffer});$0"
        },
        {
            "trigger": "cipher.getAuthTag()\tcrypto",
            "contents": "cipher.getAuthTag();$0"
        },
        {
            "trigger": "cipher.setAutoPadding([autoPadding])\tcrypto",
            "contents": "cipher.setAutoPadding(${1:[, autoPadding]});$0"
        },
        {
            "trigger": "cipher.update(data[, inputEncoding][, outputEncoding])\tcrypto",
            "contents": "cipher.update(${1:data}, ${2:[, inputEncoding]}, ${3:[, outputEncoding]});$0"
        },
        {
            "trigger": "decipher.final([outputEncoding])\tcrypto",
            "contents": "decipher.final(${1:[, outputEncoding]});$0"
        },
        {
            "trigger": "decipher.setAAD(buffer)\tcrypto",
            "contents": "decipher.setAAD(${1:buffer});$0"
        },
        {
            "trigger": "decipher.setAuthTag(buffer)\tcrypto",
            "contents": "decipher.setAuthTag(${1:buffer});$0"
        },
        {
            "trigger": "decipher.setAutoPadding([autoPadding])\tcrypto",
            "contents": "decipher.setAutoPadding(${1:[, autoPadding]});$0"
        },
        {
            "trigger": "decipher.update(data[, inputEncoding][, outputEncoding])\tcrypto",
            "contents": "decipher.update(${1:data}, ${2:[, inputEncoding]}, ${3:[, outputEncoding]});$0"
        },
        {
            "trigger": "diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])\tcrypto",
            "contents": "diffieHellman.computeSecret(${1:otherPublicKey}, ${2:[, inputEncoding]}, ${3:[, outputEncoding]});$0"
        },
        {
            "trigger": "diffieHellman.generateKeys([encoding])\tcrypto",
            "contents": "diffieHellman.generateKeys(${1:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.getGenerator([encoding])\tcrypto",
            "contents": "diffieHellman.getGenerator(${1:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.getPrime([encoding])\tcrypto",
            "contents": "diffieHellman.getPrime(${1:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.getPrivateKey([encoding])\tcrypto",
            "contents": "diffieHellman.getPrivateKey(${1:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.getPublicKey([encoding])\tcrypto",
            "contents": "diffieHellman.getPublicKey(${1:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.setPrivateKey(privateKey[, encoding])\tcrypto",
            "contents": "diffieHellman.setPrivateKey(${1:privateKey}, ${2:[, encoding]});$0"
        },
        {
            "trigger": "diffieHellman.setPublicKey(publicKey[, encoding])\tcrypto",
            "contents": "diffieHellman.setPublicKey(${1:publicKey}, ${2:[, encoding]});$0"
        },
        {
            "trigger": "diffiehellman.verifyError\tcrypto",
            "contents": "diffiehellman.verifyError$0"
        },
        {
            "trigger": "ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])\tcrypto",
            "contents": "ecdh.computeSecret(${1:otherPublicKey}, ${2:[, inputEncoding]}, ${3:[, outputEncoding]});$0"
        },
        {
            "trigger": "ecdh.generateKeys([encoding[, format]])\tcrypto",
            "contents": "ecdh.generateKeys(${1:[, encoding]}, ${2:[, format]});$0"
        },
        {
            "trigger": "ecdh.getPrivateKey([encoding])\tcrypto",
            "contents": "ecdh.getPrivateKey(${1:[, encoding]});$0"
        },
        {
            "trigger": "ecdh.getPublicKey([encoding][, format])\tcrypto",
            "contents": "ecdh.getPublicKey(${1:[, encoding]}, ${2:[, format]});$0"
        },
        {
            "trigger": "ecdh.setPrivateKey(privateKey[, encoding])\tcrypto",
            "contents": "ecdh.setPrivateKey(${1:privateKey}, ${2:[, encoding]});$0"
        },
        {
            "trigger": "ecdh.setPublicKey(publicKey[, encoding])\tcrypto",
            "contents": "ecdh.setPublicKey(${1:publicKey}, ${2:[, encoding]});$0"
        },
        {
            "trigger": "hash.digest([encoding])\tcrypto",
            "contents": "hash.digest(${1:[, encoding]});$0"
        },
        {
            "trigger": "hash.update(data[, inputEncoding])\tcrypto",
            "contents": "hash.update(${1:data}, ${2:[, inputEncoding]});$0"
        },
        {
            "trigger": "hmac.digest([encoding])\tcrypto",
            "contents": "hmac.digest(${1:[, encoding]});$0"
        },
        {
            "trigger": "hmac.update(data[, inputEncoding])\tcrypto",
            "contents": "hmac.update(${1:data}, ${2:[, inputEncoding]});$0"
        },
        {
            "trigger": "sign.sign(privateKey[, outputFormat])\tcrypto",
            "contents": "sign.sign(${1:privateKey}, ${2:[, outputFormat]});$0"
        },
        {
            "trigger": "sign.update(data[, inputEncoding])\tcrypto",
            "contents": "sign.update(${1:data}, ${2:[, inputEncoding]});$0"
        },
        {
            "trigger": "verify.update(data[, inputEncoding])\tcrypto",
            "contents": "verify.update(${1:data}, ${2:[, inputEncoding]});$0"
        },
        {
            "trigger": "verify.verify(object, signature[, signatureFormat])\tcrypto",
            "contents": "verify.verify(${1:object}, ${2:signature}, ${3:[, signatureFormat]});$0"
        },
        {
            "trigger": "crypto.createCipher(algorithm, password[, options])\tcrypto",
            "contents": "crypto.createCipher(${1:algorithm}, ${2:password}, ${3:[, options]});$0"
        },
        {
            "trigger": "crypto.createCipheriv(algorithm, key, iv[, options])\tcrypto",
            "contents": "crypto.createCipheriv(${1:algorithm}, ${2:key}, ${3:iv}, ${4:[, options]});$0"
        },
        {
            "trigger": "crypto.createCredentials(details)\tcrypto",
            "contents": "crypto.createCredentials(${1:details});$0"
        },
        {
            "trigger": "crypto.createDecipher(algorithm, password[, options])\tcrypto",
            "contents": "crypto.createDecipher(${1:algorithm}, ${2:password}, ${3:[, options]});$0"
        },
        {
            "trigger": "crypto.createDecipheriv(algorithm, key, iv[, options])\tcrypto",
            "contents": "crypto.createDecipheriv(${1:algorithm}, ${2:key}, ${3:iv}, ${4:[, options]});$0"
        },
        {
            "trigger": "crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])\tcrypto",
            "contents": "crypto.createDiffieHellman(${1:prime}, ${2:[, primeEncoding]}, ${3:[, generator]}, ${4:[, generatorEncoding]});$0"
        },
        {
            "trigger": "crypto.createDiffieHellman(primeLength[, generator])\tcrypto",
            "contents": "crypto.createDiffieHellman(${1:primeLength}, ${2:[, generator]});$0"
        },
        {
            "trigger": "crypto.createECDH(curveName)\tcrypto",
            "contents": "crypto.createECDH(${1:curveName});$0"
        },
        {
            "trigger": "crypto.createHash(algorithm[, options])\tcrypto",
            "contents": "crypto.createHash(${1:algorithm}, ${2:[, options]});$0"
        },
        {
            "trigger": "crypto.createHmac(algorithm, key[, options])\tcrypto",
            "contents": "crypto.createHmac(${1:algorithm}, ${2:key}, ${3:[, options]});$0"
        },
        {
            "trigger": "crypto.createSign(algorithm[, options])\tcrypto",
            "contents": "crypto.createSign(${1:algorithm}, ${2:[, options]});$0"
        },
        {
            "trigger": "crypto.createVerify(algorithm[, options])\tcrypto",
            "contents": "crypto.createVerify(${1:algorithm}, ${2:[, options]});$0"
        },
        {
            "trigger": "crypto.getCiphers()\tcrypto",
            "contents": "crypto.getCiphers();$0"
        },
        {
            "trigger": "crypto.getCurves()\tcrypto",
            "contents": "crypto.getCurves();$0"
        },
        {
            "trigger": "crypto.getDiffieHellman(groupName)\tcrypto",
            "contents": "crypto.getDiffieHellman(${1:groupName});$0"
        },
        {
            "trigger": "crypto.getHashes()\tcrypto",
            "contents": "crypto.getHashes();$0"
        },
        {
            "trigger": "crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)\tcrypto",
            "contents": "crypto.pbkdf2(${1:password}, ${2:salt}, ${3:iterations}, ${4:keylen}, ${5:digest}, ${6:callback});$0"
        },
        {
            "trigger": "crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)\tcrypto",
            "contents": "crypto.pbkdf2Sync(${1:password}, ${2:salt}, ${3:iterations}, ${4:keylen}, ${5:digest});$0"
        },
        {
            "trigger": "crypto.privateDecrypt(privateKey, buffer)\tcrypto",
            "contents": "crypto.privateDecrypt(${1:privateKey}, ${2:buffer});$0"
        },
        {
            "trigger": "crypto.privateEncrypt(privateKey, buffer)\tcrypto",
            "contents": "crypto.privateEncrypt(${1:privateKey}, ${2:buffer});$0"
        },
        {
            "trigger": "crypto.publicDecrypt(publicKey, buffer)\tcrypto",
            "contents": "crypto.publicDecrypt(${1:publicKey}, ${2:buffer});$0"
        },
        {
            "trigger": "crypto.publicEncrypt(publicKey, buffer)\tcrypto",
            "contents": "crypto.publicEncrypt(${1:publicKey}, ${2:buffer});$0"
        },
        {
            "trigger": "crypto.randomBytes(size[, callback])\tcrypto",
            "contents": "crypto.randomBytes(${1:size}, ${2:[, callback]});$0"
        },
        {
            "trigger": "crypto.randomFillSync(buffer[, offset][, size])\tcrypto",
            "contents": "crypto.randomFillSync(${1:buffer}, ${2:[, offset]}, ${3:[, size]});$0"
        },
        {
            "trigger": "crypto.randomFill(buffer[, offset][, size], callback)\tcrypto",
            "contents": "crypto.randomFill(${1:buffer}, ${2:[, offset]}, ${3:[, size]}, ${4:callback});$0"
        },
        {
            "trigger": "crypto.setEngine(engine[, flags])\tcrypto",
            "contents": "crypto.setEngine(${1:engine}, ${2:[, flags]});$0"
        },
        {
            "trigger": "crypto.timingSafeEqual(a, b)\tcrypto",
            "contents": "crypto.timingSafeEqual(${1:a}, ${2:b});$0"
        },
        {
            "trigger": "`crypto`_module_methods_and_properties.constants\tcrypto",
            "contents": "`crypto`_module_methods_and_properties.constants$0"
        },
        {
            "trigger": "crypto.DEFAULT_ENCODING\tcrypto",
            "contents": "crypto.DEFAULT_ENCODING$0"
        },
        {
            "trigger": "`crypto`_module_methods_and_properties.fips\tcrypto",
            "contents": "`crypto`_module_methods_and_properties.fips$0"
        }
    ]
}