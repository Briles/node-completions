{
    "scope": "source.js",
    "completions": [
        {
            "trigger": "http.createServer([options][, requestListener])\thttp",
            "contents": "http.createServer(${1:[, options]}, ${2:[, requestListener]});$0"
        },
        {
            "trigger": "http.get(options[, callback])\thttp",
            "contents": "http.get(${1:options}, ${2:[, callback]});$0"
        },
        {
            "trigger": "http.get(url[, options][, callback])\thttp",
            "contents": "http.get(${1:url}, ${2:[, options]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "http.request(options[, callback])\thttp",
            "contents": "http.request(${1:options}, ${2:[, callback]});$0"
        },
        {
            "trigger": "http.request(url[, options][, callback])\thttp",
            "contents": "http.request(${1:url}, ${2:[, options]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "agent.createConnection(options[, callback])\thttp",
            "contents": "agent.createConnection(${1:options}, ${2:[, callback]});$0"
        },
        {
            "trigger": "agent.keepSocketAlive(socket)\thttp",
            "contents": "agent.keepSocketAlive(${1:socket});$0"
        },
        {
            "trigger": "agent.reuseSocket(socket, request)\thttp",
            "contents": "agent.reuseSocket(${1:socket}, ${2:request});$0"
        },
        {
            "trigger": "agent.destroy()\thttp",
            "contents": "agent.destroy();$0"
        },
        {
            "trigger": "agent.getName(options)\thttp",
            "contents": "agent.getName(${1:options});$0"
        },
        {
            "trigger": "http.agent.freeSockets\thttp",
            "contents": "http.agent.freeSockets$0"
        },
        {
            "trigger": "http.agent.maxFreeSockets\thttp",
            "contents": "http.agent.maxFreeSockets$0"
        },
        {
            "trigger": "http.agent.maxSockets\thttp",
            "contents": "http.agent.maxSockets$0"
        },
        {
            "trigger": "http.agent.requests\thttp",
            "contents": "http.agent.requests$0"
        },
        {
            "trigger": "http.agent.sockets\thttp",
            "contents": "http.agent.sockets$0"
        },
        {
            "trigger": "request.abort()\thttp",
            "contents": "request.abort();$0"
        },
        {
            "trigger": "request.end([data[, encoding]][, callback])\thttp",
            "contents": "request.end(${1:[, data]}, ${2:[, encoding]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "request.flushHeaders()\thttp",
            "contents": "request.flushHeaders();$0"
        },
        {
            "trigger": "request.getHeader(name)\thttp",
            "contents": "request.getHeader(${1:name});$0"
        },
        {
            "trigger": "request.removeHeader(name)\thttp",
            "contents": "request.removeHeader(${1:name});$0"
        },
        {
            "trigger": "request.setHeader(name, value)\thttp",
            "contents": "request.setHeader(${1:name}, ${2:value});$0"
        },
        {
            "trigger": "request.setNoDelay([noDelay])\thttp",
            "contents": "request.setNoDelay(${1:[, noDelay]});$0"
        },
        {
            "trigger": "request.setSocketKeepAlive([enable][, initialDelay])\thttp",
            "contents": "request.setSocketKeepAlive(${1:[, enable]}, ${2:[, initialDelay]});$0"
        },
        {
            "trigger": "request.setTimeout(timeout[, callback])\thttp",
            "contents": "request.setTimeout(${1:timeout}, ${2:[, callback]});$0"
        },
        {
            "trigger": "request.write(chunk[, encoding][, callback])\thttp",
            "contents": "request.write(${1:chunk}, ${2:[, encoding]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "request.aborted\thttp",
            "contents": "request.aborted$0"
        },
        {
            "trigger": "http.clientrequest.connection\thttp",
            "contents": "http.clientrequest.connection$0"
        },
        {
            "trigger": "http.clientrequest.maxHeadersCount\thttp",
            "contents": "http.clientrequest.maxHeadersCount$0"
        },
        {
            "trigger": "req.socket\thttp",
            "contents": "req.socket$0"
        },
        {
            "trigger": "abort\thttp",
            "contents": "abort$0"
        },
        {
            "trigger": "connect\thttp",
            "contents": "connect$0"
        },
        {
            "trigger": "continue\thttp",
            "contents": "continue$0"
        },
        {
            "trigger": "information\thttp",
            "contents": "information$0"
        },
        {
            "trigger": "response\thttp",
            "contents": "response$0"
        },
        {
            "trigger": "socket\thttp",
            "contents": "socket$0"
        },
        {
            "trigger": "timeout\thttp",
            "contents": "timeout$0"
        },
        {
            "trigger": "upgrade\thttp",
            "contents": "upgrade$0"
        },
        {
            "trigger": "server.close([callback])\thttp",
            "contents": "server.close(${1:[, callback]});$0"
        },
        {
            "trigger": "server.listen()\thttp",
            "contents": "server.listen();$0"
        },
        {
            "trigger": "server.setTimeout([msecs][, callback])\thttp",
            "contents": "server.setTimeout(${1:[, msecs]}, ${2:[, callback]});$0"
        },
        {
            "trigger": "http.server.listening\thttp",
            "contents": "http.server.listening$0"
        },
        {
            "trigger": "http.server.maxHeadersCount\thttp",
            "contents": "http.server.maxHeadersCount$0"
        },
        {
            "trigger": "http.server.timeout\thttp",
            "contents": "http.server.timeout$0"
        },
        {
            "trigger": "http.server.keepAliveTimeout\thttp",
            "contents": "http.server.keepAliveTimeout$0"
        },
        {
            "trigger": "checkContinue\thttp",
            "contents": "checkContinue$0"
        },
        {
            "trigger": "checkExpectation\thttp",
            "contents": "checkExpectation$0"
        },
        {
            "trigger": "clientError\thttp",
            "contents": "clientError$0"
        },
        {
            "trigger": "close\thttp",
            "contents": "close$0"
        },
        {
            "trigger": "connection\thttp",
            "contents": "connection$0"
        },
        {
            "trigger": "request\thttp",
            "contents": "request$0"
        },
        {
            "trigger": "response.addTrailers(headers)\thttp",
            "contents": "response.addTrailers(${1:headers});$0"
        },
        {
            "trigger": "response.end([data][, encoding][, callback])\thttp",
            "contents": "response.end(${1:[, data]}, ${2:[, encoding]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "response.getHeader(name)\thttp",
            "contents": "response.getHeader(${1:name});$0"
        },
        {
            "trigger": "response.getHeaderNames()\thttp",
            "contents": "response.getHeaderNames();$0"
        },
        {
            "trigger": "response.getHeaders()\thttp",
            "contents": "response.getHeaders();$0"
        },
        {
            "trigger": "response.hasHeader(name)\thttp",
            "contents": "response.hasHeader(${1:name});$0"
        },
        {
            "trigger": "response.removeHeader(name)\thttp",
            "contents": "response.removeHeader(${1:name});$0"
        },
        {
            "trigger": "response.setHeader(name, value)\thttp",
            "contents": "response.setHeader(${1:name}, ${2:value});$0"
        },
        {
            "trigger": "response.setTimeout(msecs[, callback])\thttp",
            "contents": "response.setTimeout(${1:msecs}, ${2:[, callback]});$0"
        },
        {
            "trigger": "response.write(chunk[, encoding][, callback])\thttp",
            "contents": "response.write(${1:chunk}, ${2:[, encoding]}, ${3:[, callback]});$0"
        },
        {
            "trigger": "response.writeContinue()\thttp",
            "contents": "response.writeContinue();$0"
        },
        {
            "trigger": "response.writeHead(statusCode[, statusMessage][, headers])\thttp",
            "contents": "response.writeHead(${1:statusCode}, ${2:[, statusMessage]}, ${3:[, headers]});$0"
        },
        {
            "trigger": "response.writeProcessing()\thttp",
            "contents": "response.writeProcessing();$0"
        },
        {
            "trigger": "http.serverresponse.connection\thttp",
            "contents": "http.serverresponse.connection$0"
        },
        {
            "trigger": "http.serverresponse.finished\thttp",
            "contents": "http.serverresponse.finished$0"
        },
        {
            "trigger": "http.serverresponse.headersSent\thttp",
            "contents": "http.serverresponse.headersSent$0"
        },
        {
            "trigger": "http.serverresponse.sendDate\thttp",
            "contents": "http.serverresponse.sendDate$0"
        },
        {
            "trigger": "res.socket\thttp",
            "contents": "res.socket$0"
        },
        {
            "trigger": "response.statusCode\thttp",
            "contents": "response.statusCode$0"
        },
        {
            "trigger": "response.statusMessage\thttp",
            "contents": "response.statusMessage$0"
        },
        {
            "trigger": "finish\thttp",
            "contents": "finish$0"
        },
        {
            "trigger": "message.destroy([error])\thttp",
            "contents": "message.destroy(${1:[, error]});$0"
        },
        {
            "trigger": "message.setTimeout(msecs, callback)\thttp",
            "contents": "message.setTimeout(${1:msecs}, ${2:callback});$0"
        },
        {
            "trigger": "message.aborted\thttp",
            "contents": "message.aborted$0"
        },
        {
            "trigger": "message.complete\thttp",
            "contents": "message.complete$0"
        },
        {
            "trigger": "request.headers\thttp",
            "contents": "request.headers$0"
        },
        {
            "trigger": "message.httpVersion\thttp",
            "contents": "message.httpVersion$0"
        },
        {
            "trigger": "http.incomingmessage.method\thttp",
            "contents": "http.incomingmessage.method$0"
        },
        {
            "trigger": "request.rawHeaders\thttp",
            "contents": "request.rawHeaders$0"
        },
        {
            "trigger": "http.incomingmessage.rawTrailers\thttp",
            "contents": "http.incomingmessage.rawTrailers$0"
        },
        {
            "trigger": "net.Socket\thttp",
            "contents": "net.Socket$0"
        },
        {
            "trigger": "http.incomingmessage.statusCode\thttp",
            "contents": "http.incomingmessage.statusCode$0"
        },
        {
            "trigger": "http.incomingmessage.statusMessage\thttp",
            "contents": "http.incomingmessage.statusMessage$0"
        },
        {
            "trigger": "http.incomingmessage.trailers\thttp",
            "contents": "http.incomingmessage.trailers$0"
        },
        {
            "trigger": "request.url\thttp",
            "contents": "request.url$0"
        },
        {
            "trigger": "aborted\thttp",
            "contents": "aborted$0"
        },
        {
            "trigger": "http.METHODS\thttp",
            "contents": "http.METHODS$0"
        },
        {
            "trigger": "http.STATUS_CODES\thttp",
            "contents": "http.STATUS_CODES$0"
        },
        {
            "trigger": "http.globalAgent\thttp",
            "contents": "http.globalAgent$0"
        }
    ]
}